---
layout: post
title: "(Ab)using WCF for Serving HTTP GET Requests"
date: 2007-02-20
tags: ["software development", "web services", "c#"]
permalink: /2007/02/-ab-using-wcf-for-serving-http-get-requests.html
comments: false
---
{% include JB/setup %}

<div class='post'>
There's an interesting sample in the .NET 3.0 SDK docu called <a href="http://msdn2.microsoft.com/en-us/library/aa395208.aspx" target="_blank">REST and POX</a> that demonstrates how WCF can be used to send and receive “plain old XML” (POX) messages over HTTP GET.<br /><br />I stumbled across this sample the other day because I was looking for some information on how I could serve simple HTTP GET requests from WCF. The motivation behind all this was that I wanted to implement HTTP GET meta-data retrieval for an <a href="http://www.ssdl.org/" target="_blank">SSDL</a> contract using the <span style="font-family:courier new;">?ssdl</span> convention, i.e. you deploy an <a href="http://www.ssdl.org/" target="_blank">SSDL</a> service in <a href="http://sourceforge.net/projects/soya" target="_blank">Soya</a>, fire up your browser, add <span style="font-family:courier new;">?ssdl</span> to the end of the base address of the service, et voilà you'll get the <a href="http://www.ssdl.org/" target="_blank">SSDL</a> contract XML flickering across your screen.<br /><br />Although I'll use the <a href="http://www.ssdl.org/" target="_blank">SSDL</a> meta-data as an example in this post, the techniques I'm describing here should apply to serving HTTP GET requests in general and could also be used for e.g. serving custom help pages and so on.<br /><br />Unlike in the <a href="http://msdn2.microsoft.com/en-us/library/aa395208.aspx" target="_blank">REST and POX</a> example I had to configure the WCF runtime manually, because I wanted to serve HTTP GET requests just concurrently of a running service, which was using SOAP for communicating. In the following steps I'll thus explain, how the WCF runtime can be manually configured for that purpose.<br /><br />First, I created an <span style=";font-family:courier new;font-size:85%;"  >IServiceBehavior</span> so that the meta functionality can easily be added to or removed from services. In the Behaviors' <span style=";font-family:courier new;font-size:85%;"  >ApplyDispatchBehavior()</span> method I create a new <span style=";font-family:courier new;font-size:85%;"  >ChannelDispatcher</span> and added it to the service host.<br /><br /><span style=";font-family:courier new;font-size:85%;"  >ChannelDispatcher cd = CreateMetaDispatcher(host, baseUri);<br />host.ChannelDispatchers.Add(cd);</span><br /><br />Now to the more interesting part, i.e. the <span style=";font-family:courier new;font-size:85%;"  >CreateMetaDispatcher()</span>. I created the <span style=";font-family:courier new;font-size:85%;"  >EndpointAddress</span> where I wanted the service to be listening:<br /><br /><span style=";font-family:courier new;font-size:85%;"  >EndpointAddress address = new EndpointAddress(listenUri);</span><br /><br />Then, I created a new custom binding by composing a HTTP and Text encoding binding elements. Note that I set <span style=";font-family:courier new;font-size:85%;"  >MessageVersion</span> to <span style=";font-family:courier new;font-size:85%;"  >None</span>, because HTTP GET requests have (obviously) no message version information in that sense.<br /><br /><span style=";font-family:courier new;font-size:85%;"  >HttpTransportBindingElement transport = new HttpTransportBindingElement();<br />TextMessageEncodingBindingElement text = new TextMessageEncodingBindingElement();<br />text.MessageVersion = MessageVersion.None;<br />Binding binding = new CustomBinding(text, transport);</span><br /><br />Next, I created a <span style=";font-family:courier new;font-size:85%;"  >ChannelListener</span> using an <span style=";font-family:courier new;font-size:85%;"  >IReplyChannel</span> and the <span style=";font-family:courier new;font-size:85%;"  >ChannelDispatcher</span> with the above binding.<br /><br /><span style=";font-family:courier new;font-size:85%;"  >IChannelListener listener = binding.BuildChannelListener<ireplychannel>(listenUri);<br />ChannelDispatcher cd = new ChannelDispatcher(listener, "SoyaHttpBinding", binding);<br />cd.MessageVersion = MessageVersion.None;</ireplychannel></span><br /><br />Following that, I created an instance of the service implementation (I'll come to that later), built the <span style=";font-family:courier new;font-size:85%;"  >EndpointDispatcher</span> and configured it to be a bit promiscuous (i.e. set a <span style=";font-family:courier new;font-size:85%;"  >MatchAllMessageFilter</span>). I also had to write a custom <span style=";font-family:courier new;font-size:85%;"  >IInstanceProvider</span> and <span style=";font-family:courier new;font-size:85%;"  >IInstanceContextProvider</span>, because even though implementations exist in WCF, they are accessible only intra-assembly, which is a bit *#@!...<br /><br /><span style=";font-family:courier new;font-size:85%;"  >IHttpService service = new HttpGetMetadata();<br />EndpointDispatcher ed = new EndpointDispatcher(address, "IHttpGetMetadata", "urn:soya:runtime");<br />ed.ContractFilter = new MatchAllMessageFilter();<br />ed.DispatchRuntime.InstanceProvider = new SimpleInstanceProvider(new HttpGetMetadata());<br />ed.DispatchRuntime.InstanceProvider = new SimpleInstanceProvider(service);<br />ed.DispatchRuntime.InstanceContextProvider = new SingletonInstanceContextProvider();<br />ed.DispatchRuntime.SingletonInstanceContext = new InstanceContext(host, service);</span><br /><br />Further, I created the <span style=";font-family:courier new;font-size:85%;"  >DispatchOperation</span> that will be invoked for serving the HTTP requests. Same story here: I had to write a custom <span style=";font-family:courier new;font-size:85%;"  >IOperationInvoker</span> because none of the WCF implementations can be accessed publicly. Luckily, by setting <span style=";font-family:courier new;font-size:85%;"  >DeserializeRequest</span> and <span style=";font-family:courier new;font-size:85%;"  >SerializeReply</span> to <span style=";font-family:courier new;font-size:85%;"  >false</span>, I didn't have to provide a custom <span style=";font-family:courier new;font-size:85%;"  >IOperationFormatter</span>, because the incoming and outgoing <span style=";font-family:courier new;font-size:85%;"  >Message</span> instances will be delivered straight to the service implementation.<br /><br /><span style=";font-family:courier new;font-size:85%;"  >DispatchOperation operation = new DispatchOperation(ed.DispatchRuntime, "Process", "*", "*");<br />MethodInfo method = service.GetType().GetMethod("Process");<br />operation.Invoker = new MessageOperationInvoker(method);<br />operation.DeserializeRequest = false;<br />operation.SerializeReply = false;</span><br /><br />Finally, I made the above operation responsible for processing all requests and assigned the  belonging <span style=";font-family:courier new;font-size:85%;"  >EndpointDispatcher</span> to the previously created <span style=";font-family:courier new;font-size:85%;"  >ChannelDispatcher</span>.<br /><br /><span style=";font-family:courier new;font-size:85%;"  >ed.DispatchRuntime.UnhandledDispatchOperation = operation;<br />cd.Endpoints.Add(ed);</span><br /><br />The service contract and implementation are pretty straight-forward and basically identical to the ones in the <a href="http://msdn2.microsoft.com/en-us/library/aa395208.aspx" target="_blank">REST and POX</a> example.<br /><br /><span style=";font-family:courier new;font-size:85%;"  >[ServiceContract]<br />public interface IHttpService {<br />[OperationContract(Action = "*", ReplyAction = "*")]<br />Message Process(Message msg);<br />}<br /><br />public Message Process(Message request) {<br />// do some HTTP request processing here and send a HTTP response<br />}</span><br /><br />In the above <span style=";font-family:courier new;font-size:85%;"  >Process()</span> method I check the query string for the <span style=";font-family:courier new;font-size:85%;"  >ssdl</span> parameter and return (after some error checking etc) a HTTP response <span style=";font-family:courier new;font-size:85%;"  >Message</span> that has the HTTP StatusCode set to 200 and ContentType to "text/xml".<br /><br /><span style=";font-family:courier new;font-size:85%;"  >private Message CreateSsdlResponse() {<br />SsdlDescription ssdl = SoyaServiceHost.Current.Runtime.Ssdl;<br />Message reply = new SsdlMessage(ssdl);<br />HttpResponseMessageProperty property = new HttpResponseMessageProperty();<br />property.StatusCode = HttpStatusCode.OK;<br />property.Headers.Add(HttpResponseHeader.ContentType, xmlContentType);<br />reply.Properties.Add(HttpResponseMessageProperty.Name, property);<br /><br />return reply;<br />}</span><br /><br />The <span style=";font-family:courier new;font-size:85%;"  >SsdlMessage</span> class is nothing else but a subclass of Message that has no headers, no version and overwrites the <span style=";font-family:courier new;font-size:85%;"  >OnWriteBodyContents()</span> method to output the SSDL contract.<br /><br /><span style=";font-family:courier new;font-size:85%;"  >protected override void OnWriteBodyContents(XmlDictionaryWriter writer) {<br /> ssdl.GetInfoSet().WriteContentTo(writer);<br />}</span><br /><br />If you're trying to install the <span style=";font-family:courier new;font-size:85%;"  >ChannelListener</span> on the base address of your service, you should also make sure that there are no other <span style=";font-family:courier new;font-size:85%;"  >ChannelListeners</span> configured in the runtime that interfere with your <span style=";font-family:courier new;font-size:85%;"  >ChannelListener</span> (e.g. disable WCF's <span style=";font-family:courier new;font-size:85%;"  >ServiceMetadataBehavior</span>, disable <span style=";font-family:courier new;font-size:85%;"  >HttpHelpPageEnabled</span> in <span style=";font-family:courier new;font-size:85%;"  >ServiceDebugBehavior</span>, etc.).<br /><br />The complete source of the discussed meta-data example can be accessed via the <a href="http://soya.svn.sourceforge.net/viewvc/soya/trunk/soya/src/main/cs/Soya/WCF/" target="_blank">Soya SVN repository</a>. For those who don't like browsing, here are direct links to the main classes:<br /><br /><a name="MetaBehavior.cs" href="http://soya.svn.sourceforge.net/viewvc/soya/trunk/main/WCF/MetaBehavior.cs?revision=121&view=markup" target="_blank">MetaBehavior.cs</a><br /><a name="IHttpService.cs" href="http://soya.svn.sourceforge.net/viewvc/soya/trunk/main/WCF/IHttpService.cs?revision=120&amp;view=markup" target="_blank"> IHttpService.cs</a><br /><a name="HttpGetMetadata.cs" href="http://soya.svn.sourceforge.net/viewvc/soya/trunk/main/WCF/HttpGetMetadata.cs?revision=120&view=markup" target="_blank">HttpGetMetadata.cs</a><br /><br /><div style="text-align: center;"><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://2.bp.blogspot.com/_MoEdKdmWnk0/Rdr1-abc7II/AAAAAAAAABg/wKjmuWNeSeo/s1600-h/ssdl-screen.png"><img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://2.bp.blogspot.com/_MoEdKdmWnk0/Rdr1-abc7II/AAAAAAAAABg/wKjmuWNeSeo/s320/ssdl-screen.png" alt="" id="BLOGGER_PHOTO_ID_5033605986135108738" border="0" /></a><br /></div>
</div>
