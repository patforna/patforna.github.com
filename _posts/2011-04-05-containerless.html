---
layout: post
title: "ContainerLess"
date: 2011-04-05
tags: ["java", "software development", "web"]
permalink: /2011/04/containerless.html
comments: false
---
{% include JB/setup %}

<div class='post'>
I've recently worked on a project where we built a relatively small web application for a client. There was a hard release date, which gave us less than 4 weeks to build and deliver the application. There were several things we did to ensure that we would be able to release on time. One of the them was making sure very early that we could deploy the new application into a production-like environment. During the first few days, we therefore invested time in building infrastructure to deploy the application automatically and continuously (i.e. after each build) to a production-like environment. Going through this process was useful in several different ways:<ul><li>it made us think early on in the project, what will be required to run the application in production (e.g. operating system, software, ports, certificates, etc.). This gave us sufficient time to react to unexpected obstacles;</li><br /><li>by automating the deployment process early, we reduced the number of times we had to do this activity manually later on;</li><br /><li>seeing the application work in a production-like environment was encouraging feedback that we would be able to release to production whenever our client required;</li><br /><li>deploying the application while it was still very simple allowed us to focus on the deployment process without getting distracted by problems caused by the application.</li></ul><h3>Ditching the Container</h3><p>When we first tried to deploy the application, it was not much more than a Hello World web application. We decided to use Jetty as a web server, since we had used it many times on projects before - both standalone and embedded. Whenever we used Jetty in the past, however, we would normally build a WAR file or a WAR-like directory structure, write a web deployment descriptor and finally deploy or load the artefact into Jetty.</p><p>Having spent a bit of time working on a Ruby on Rails application recently, the deployment process used in the past seemed cumbersome and complicated - even more so given the simplicity of the application at hand. That's when we realised that what we cared most about is the application itself and to a much lesser extent the container. In fact, we didn't care about the container at all. All we cared about was that our application would be able to serve incoming requests. At some point, we started to think of the application more of as a self-contained program, which just happened to expose some of its functionality via HTTP. The diagram below illustrates this mind-shift.</p><div style="text-align: center;"><a href="http://3.bp.blogspot.com/-K2lhkdG6xjI/TZrwPZm9HmI/AAAAAAAAAJQ/i014GAjqvQI/s1600/container-less.png" onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}"><img style="cursor:pointer; cursor:hand;width: 400px; height: 265px;" src="http://3.bp.blogspot.com/-K2lhkdG6xjI/TZrwPZm9HmI/AAAAAAAAAJQ/i014GAjqvQI/s400/container-less.png" border="0" alt="" id="BLOGGER_PHOTO_ID_5592046034696871522" /></a></div><h3>Consequences</h3><p>The biggest change was the mind-shift. It took some time to get used to the idea that the application is no longer "contained" in something else, but that it can be "self-contained". But there were also a number of other practical consequences that this change entailed:</p><ul><li>simplified development process. It was very easy and fast for developers to run the application in the same way as it would run in production;</li><br /><li>simplified testing. It was very easy to start and stop the application for automated functional tests;</li><br /><li>simplified packaging and deployment process (e.g. no web.xml, no war file, no prescribed directory structure, etc.);</li><br /><li>simplified application start (i.e. simply execute a Java program);</li><br /><li>started using standard DI mechanisms to wire up Jetty as a dependency and injected it where needed.*</li></ul><p>* Strictly speaking, you don't need to ditch the container to do this but we felt that the mind-shift we had gone through enabled us to see the potential for doing this.</p><h3>Conclusion</h3><p>Making this architectural change simplified our development and deployment process. It also simplified the way we thought about the application. The only price we paid was loosing the ability to deploy the application to different web server without making changes. Fortunately, this price was purely hypothetical because we had absolutely no need nor desire to use a different web server in production. On the positive side, we were now hiding the fact that we were relying on Java Servlets to realise our web functionality. In fact, seeing what some of the other communities are building (e.g. Sinatra, Node.js, etc.), I'd be tempted to try to write a web application that doesn't use Servlets at all. Part of it for fun, part of it to overcome some of the limitations inherent with the Servlet model.</p>
</div>
