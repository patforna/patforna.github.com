---
layout: post
title: Private Method Anti(?)-Pattern
date: 2008-05-06
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
Some (actually quite a long) time ago, <a target="_blank" href="http://monkeyisland.pl/">Szczepan</a> asked if <a target="_blank" href="http://monkeyisland.pl/2008/01/05/private-method-antipattern/">private methods are an anti-pattern</a> and I've been promising him ever since to post a reply. The reasoning behind his statement was derived from the fact that TDD purists often maintain that untestable code is very likely bad code. Private methods are hard to test and it therefore seems to follow naturally that they, too, are a sign of bad code. While I'm sure that this is true in some cases, I think there are a lot of good reasons to have private methods or classes.<br /><br /><span style="font-weight: bold;">Implementation vs. Behavior</span><br /><br />Many developers focus too much on implementation details when they write tests. Ask yourself what you really care about a class: implementation details or behavior? It turns out that in most cases, one is only interested in the latter. So when writing tests, we should focus more on the public API of a class and not about its internal structure.<br /><br /><span style="font-weight: bold;">Modularization vs. Encapsulation</span><br /><br />In summary, I agree with <a target="_blank" href="http://monkeyisland.pl/">Szczepan</a> when he says that there is probably a lot of code out there in which private methods could be factored out into public classes or methods which would, in turn, increase code modularity. Often, however, encapsulation and a lean public API might be favored over modularization. More importantly, modularization might not always be needed, and therefore complicate and bloat the codebase unnecessarily. If modularization is still required at a later stage, internal code can be refactored and made public without breaking existing code.<br /><br /><span style="font-weight: bold;">Are You Over-Mocking?</span><br /><br />Stubbing and mocking techniques and tools, especially <a target="_blank" href="http://code.google.com/p/mockito/">Mockito</a>, are great and make perfect sense in many situations (e.g. faking a network connection, a database, a service etc.). Breaking up a public method that consists of <span style="font-style: italic;">n</span> private methods into <span style="font-style: italic;">n</span> public methods of <span style="font-style: italic;">n</span> new classes only so that we can test that the methods are indeed invoked, however, introduces unwanted complexity and completely breaks encapsulation principles, without yielding any real benefits.<br /><br /><span style="font-weight: bold;">Don't Defend Yourself!</span><br /><br />Private methods and classes are also a good thing because they allow to code non-defensively, which will make code simpler. As soon as logic is offered to the world as a public method, one needs to ensure that the implementation also caters for unexpected scenarios. If the implementation is private, on the other hand, it is easy to determine that a certain variable will never be <span style="font-style: italic;">null</span>, for example, and can thus be safely ignored.<br /><br /><span style="font-weight: bold;">Public APIs are Contracts</span><br /><br />The API of a class (i.e. it's non-private methods) represents a contract with whoever is going to use it. Sure, as long as the class is used only within a single source repository this might not be a big issues, because powerful refactoring tools make it easy to change the contracts. But what happens if code is being used externally - maybe because other people find it useful, too? It won't be possible to change public method signatures that easily anymore, because other code will have been built on top of them.<br /><br /><span style="font-weight: bold;">Reduce Public API complexity</span><br /><br />Private methods and classes can greatly reduce the complexity of a public API. Compare the Java API and its source code, for example. You'll realize that a lot of complexity is encapsulated in private methods and classes, which is a good thing, because it keeps the public APIs complexity low(er(-ish)).<br /><br /><span style="font-weight: bold;">To sum up...</span><br /><br />Although these are very much thoughts-in-progress, I think that in summary:<br /><ul><li>We focus too much on implementation details and not enough on externally observable behavior of a class when writing tests</li><li>We often create code that is unnecessarily modular, because we are test-obsessed</li><li>We often mock too much (probably as a consequence or mutual reaction of the above two points)</li><li>We often create APIs that expose too much and therefore break encapsulation</li></ul></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>seo.media</div>
<div class='content'>
Ecommerce and <a href="http://www.eberrymedia.com" rel="nofollow">offshore software development</a> are burgeoning trends these days and several India-based offshore software development companies have gained reputation for offering excellent services to the clientele throughout the world. However, it would be extremely advantageous for you to assign your software development project to one of the popular India-based company because services offered by Indian software companies are cost-effective and flexible that ensure future growth and transparency.<a href="http://www.eberrymedia.com" rel="nofollow">http://www.eberrymedia.com</a></div>
</div>
<div class='comment'>
<div class='author'>cenkcivici</div>
<div class='content'>
Behavior should be observed through public methods. Private methods are almost always a result of Extract method refactoring when doing TDD. When I feel the need to test private methods, I am testing the implementation, not the behavior and this is a sign that these private methods dont belong to the class under test.</div>
</div>
<div class='comment'>
<div class='author'>web</div>
<div class='content'>
There is a lot of competition in outsourcing software development, as there are many firms across the globe catering to clients looking for outsourcing their work. What is good is that the takers can choose the best from the lot.<A HREF="http://www.infysolutions.com" REL="nofollow"> http://www.infysolutions.com</A>.</div>
</div>
<div class='comment'>
<div class='author'>Jim Barritt</div>
<div class='content'>
ENCAPSULATION!</div>
</div>
<div class='comment'>
<div class='author'>euluis</div>
<div class='content'>
I normally don't like private methods, but, that does not necessarily mean that I make them public. Java has the default visibility - package. This avoids boilerplate and it won't pollute the API.<BR/><BR/>The other classes in the same package will be polite in their usage of these non-API methods.<BR/><BR/>My main idea is that it is not private vs public...</div>
</div>
<div class='comment'>
<div class='author'>Simon Brunning</div>
<div class='content'>
Testing is important, but we shouldn't get tunnel vision - people have to <B>use</B> our API too. There are some powerful arguments against marking everything private <A HREF="http://www.brunningonline.net/simon/blog/archives/000528.html#000528" REL="nofollow">here</A>.</div>
</div>
</div>
