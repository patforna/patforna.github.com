---
layout: post
title: "Private Method Anti(?)-Pattern"
date: 2008-05-06
tags: ["software development"]
permalink: /2008/05/private-method-anti-pattern.html
comments: false
---
{% include JB/setup %}

<div class='post'>
Some (actually quite a long) time ago, <a target="_blank" href="http://monkeyisland.pl/">Szczepan</a> asked if <a target="_blank" href="http://monkeyisland.pl/2008/01/05/private-method-antipattern/">private methods are an anti-pattern</a> and I've been promising him ever since to post a reply. The reasoning behind his statement was derived from the fact that TDD purists often maintain that untestable code is very likely bad code. Private methods are hard to test and it therefore seems to follow naturally that they, too, are a sign of bad code. While I'm sure that this is true in some cases, I think there are a lot of good reasons to have private methods or classes.<br /><br /><span style="font-weight: bold;">Implementation vs. Behavior</span><br /><br />Many developers focus too much on implementation details when they write tests. Ask yourself what you really care about a class: implementation details or behavior? It turns out that in most cases, one is only interested in the latter. So when writing tests, we should focus more on the public API of a class and not about its internal structure.<br /><br /><span style="font-weight: bold;">Modularization vs. Encapsulation</span><br /><br />In summary, I agree with <a target="_blank" href="http://monkeyisland.pl/">Szczepan</a> when he says that there is probably a lot of code out there in which private methods could be factored out into public classes or methods which would, in turn, increase code modularity. Often, however, encapsulation and a lean public API might be favored over modularization. More importantly, modularization might not always be needed, and therefore complicate and bloat the codebase unnecessarily. If modularization is still required at a later stage, internal code can be refactored and made public without breaking existing code.<br /><br /><span style="font-weight: bold;">Are You Over-Mocking?</span><br /><br />Stubbing and mocking techniques and tools, especially <a target="_blank" href="http://code.google.com/p/mockito/">Mockito</a>, are great and make perfect sense in many situations (e.g. faking a network connection, a database, a service etc.). Breaking up a public method that consists of <span style="font-style: italic;">n</span> private methods into <span style="font-style: italic;">n</span> public methods of <span style="font-style: italic;">n</span> new classes only so that we can test that the methods are indeed invoked, however, introduces unwanted complexity and completely breaks encapsulation principles, without yielding any real benefits.<br /><br /><span style="font-weight: bold;">Don't Defend Yourself!</span><br /><br />Private methods and classes are also a good thing because they allow to code non-defensively, which will make code simpler. As soon as logic is offered to the world as a public method, one needs to ensure that the implementation also caters for unexpected scenarios. If the implementation is private, on the other hand, it is easy to determine that a certain variable will never be <span style="font-style: italic;">null</span>, for example, and can thus be safely ignored.<br /><br /><span style="font-weight: bold;">Public APIs are Contracts</span><br /><br />The API of a class (i.e. it's non-private methods) represents a contract with whoever is going to use it. Sure, as long as the class is used only within a single source repository this might not be a big issues, because powerful refactoring tools make it easy to change the contracts. But what happens if code is being used externally - maybe because other people find it useful, too? It won't be possible to change public method signatures that easily anymore, because other code will have been built on top of them.<br /><br /><span style="font-weight: bold;">Reduce Public API complexity</span><br /><br />Private methods and classes can greatly reduce the complexity of a public API. Compare the Java API and its source code, for example. You'll realize that a lot of complexity is encapsulated in private methods and classes, which is a good thing, because it keeps the public APIs complexity low(er(-ish)).<br /><br /><span style="font-weight: bold;">To sum up...</span><br /><br />Although these are very much thoughts-in-progress, I think that in summary:<br /><ul><li>We focus too much on implementation details and not enough on externally observable behavior of a class when writing tests</li><li>We often create code that is unnecessarily modular, because we are test-obsessed</li><li>We often mock too much (probably as a consequence or mutual reaction of the above two points)</li><li>We often create APIs that expose too much and therefore break encapsulation</li></ul>
</div>
