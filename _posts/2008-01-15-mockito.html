---
layout: post
title: Mockito
date: 2008-01-15
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
My colleague <a href="http://monkeyisland.pl/" target="_blank=">Szczepan</a> has just released a new mocking library called <a href="http://code.google.com/p/mockito/" target="_blank">Mockito</a> (I leave it up to your imagination to picture the situation in which he came up with the name...).<br /><br />Essentially, <a href="http://code.google.com/p/mockito/" target="_blank">Mockito</a> is built upon <a href="http://easymock.org/" target="_blank">EasyMock</a> but seems to provide a more elegant approach and simpler API to testing using mock objects than the latter. For example, I always found the <a href="http://easymock.org/" target="_blank">EasyMock's</a> recording and replaying stages quite cumbersome. Not suprisingly, I'm thus really glad to see that <a href="http://monkeyisland.pl/" target="_blank=">Szczepan</a> came up with a simpler solution in which stubbing and verification are separated into different steps. This means that you stub your objects first, then use them, and finally verify only the interactions (with the mock objects) that you're interested in.<br /><br />The following sample code is from the <a href="http://code.google.com/p/mockito/" target="_blank">Mockito</a> project site:<br /><span style=";font-family:courier new;font-size:85%;"  >import static org.mockito.Mockito.*;<br /><br />//let's mock a List!<br />List mockedList = mock(List.class);<br /><br />//stubbing<br />stub(mockedList.get(0)).toReturn("first element");<br /><br />//using mock object<br />mockedList.add("one");<br />mockedList.clear();<br /><br />//verification<br />verify(mockedList).add("one");<br />verify(mockedList).clear();</span><br /><br />I really look forward to using it more and finding out if it indeed makes testing easier. It surely does look promising =)</div>
<h2>Comments</h2>
<div class='comments'>
</div>
